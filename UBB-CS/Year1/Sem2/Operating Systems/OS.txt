exam-ew01.txt
grep -E -i "([aeiou].*){3,}" fisier.txt

exam-ew02.txt
Prints the letter A and stops afterwards

exam-ew08.txt
daca un proces refera o pagina, e posibil sarefer curand paginile
invecinate
cand incarcam o pagina referita, aducem si cateva pagini de langa ea

exam-ew06.txt
B A D C would be the correct order for minimal delay

exam-ew05.txt
the risk is of getting a deadlock, because the mutexes
are not unlocked in the order they were locked in

exam-ew08.txt
First-fit would leave a lot of unused little spaces between processes
where it is unlickely a new process could fit, butit is fast
Worst fit is slower but the space left from where the process was put
untill the next process can be big enaugh to fit another process

exam-ew09.txt
The most prioritary memory page is 0( 00-not written and not read recently),
then next in priority is 1(01, written recently) and then 2(10, read recently)

exam-ew10.txt
B/A raised to the power of 3

exam-ew01.txt
grep -E "^[^b]*[a]+[^b]*$" fisier.txt

exam-ew02.txt
5 child processes

exam-ew04.txt
It depends on the number of cores the processing unit has. 

exam-ew06.txt
Because they are slow, they should be out of the state run, but not sent back
to the ready state because they might enter run again, so they are placed in wait.

exam-ew03.txt
process A:
int x = open("x", O_WRONLY);
int z = open("z", O_RDONLY);
process B:
int y = open("y", O_WRONLY);
int x = open("x", O_RDONLY);
process C:
int z = open("z", O_WRONLY);
int y = open("y", O_RDONLY);

denis-problem.txt
fd = open("fisier");
int copy = dup(1);
dup2(fd, 1);
dup2(copy, 1); 
cout<<"alin";

exam-ew05.txt
T = 3, 6
N1 = 1, 3
N2 = 1, 2
N3 = 1, 2

Q1
Because the I/O operations are slow so you want to free the resources of the procesor, but the process that contains it
should not be put in ready state as it might be taken back to run so it is put in wait state until the I/O operations finish
Q2
The adress is its physical adress

Exam test j
1.
grep "1[0]{2,}[^1]*" a.txt

2.
sed -E -e -i "s/[13579][13579][aeiou]/\2-\1-\3-/g" 


























